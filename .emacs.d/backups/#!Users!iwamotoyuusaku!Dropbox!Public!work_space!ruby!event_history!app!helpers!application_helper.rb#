# -*- coding: utf-8 -*-
module ApplicationHelper
  # ATNDにしか対応してない
  def event_reach(event_page_url)
    hashtag = get_hashtag(event_page_url)
    tweets = get_hashtags_tweet(hashtag)
    account_list = get_account_list(tweets)

  end


  private

  def parse(response)
    json = JSON.parse(response)
    puts json["error"] if json.key?("error")
    json
  end
  
  def get_hashtag(url)
    html = Nokogiri.HTML(open(url))
    hashtag = html.xpath('//div[@id="hash-content"]/ul/li/a').text
  end
  
  def get_hashtags_tweet(encoded_query)
    http = Net::HTTP.new('search.twitter.com')
    result = []
    loop do
      response = nil
      uri = "/search.json#{encoded_query}"
      http.start do |s|
        response = s.get(uri)
      end # do
      res_hash = parse(response.body)
      if result.empty? && !res_hash.key?("results")
        # 1ページ目からレスポンスの"results"の値が空の配列[]だった場合
        # TODO 自動でもう一度リクエストするようにしたらどうか
        puts "--ERROR-- 検索結果の取得に失敗しました。"
      end # if
      result += res_hash["results"]
      break unless res_hash.key?("next_page")
      encoded_query = res_hash["next_page"]
    end # loop do
    result
  end # get_hashtags_tweet
  
  def get_account_list(tweets)
    account_list = {}
    http = Net::HTTP.new('api.twitter.com')
    response = nil
    tweets.each do |tweet|
      account = tweet["from_user"]
      unless account_list.key? account
        http.start do |s|
          uri = "/1/followers/ids.json" << URI.encode("?screen_name=#{account}")
          response = s.get(uri)
        end # http do
        res_hash = parse(response.body)
        account_list[account] = res_hash["ids"].size
      end # unless
    end # tweets do
    account_list
  end
end
